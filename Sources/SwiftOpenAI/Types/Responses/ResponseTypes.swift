import Foundation

// MARK: - Response

/// A response from the Responses API.
public struct Response: Codable, Sendable {
    /// The unique identifier for this response.
    public let id: String
    /// The object type, always `"response"`.
    public let object: String
    /// The Unix timestamp (in seconds) of when the response was created.
    public let createdAt: Int?
    /// The model used to generate the response.
    public let model: String
    /// The output items generated by the model.
    public let output: [ResponseOutputItem]
    /// The status of the response.
    public let status: String
    /// Token usage statistics for the response.
    public let usage: ResponseUsage?
    /// Arbitrary key-value metadata attached to the response.
    public let metadata: [String: String]?
    /// The ID of the previous response in a multi-turn conversation.
    public let previousResponseId: String?
    /// The system fingerprint for this response.
    public let systemFingerprint: String?
    /// Whether the response is stored for later retrieval.
    public let store: Bool?
    /// The temperature used for generation.
    public let temperature: Double?
    /// The top_p value used for generation.
    public let topP: Double?
    /// The maximum output tokens requested.
    public let maxOutputTokens: Int?
    /// Truncation strategy used.
    public let truncation: String?
    /// Incomplete details, if the response was truncated.
    public let incompleteDetails: IncompleteDetails?
    /// Error information, if the response failed.
    public let error: ResponseError?

    /// Creates a `Response` instance (useful for testing).
    public init(
        id: String,
        object: String = "response",
        createdAt: Int? = nil,
        model: String,
        output: [ResponseOutputItem],
        status: String = "completed",
        usage: ResponseUsage? = nil,
        metadata: [String: String]? = nil,
        previousResponseId: String? = nil,
        systemFingerprint: String? = nil,
        store: Bool? = nil,
        temperature: Double? = nil,
        topP: Double? = nil,
        maxOutputTokens: Int? = nil,
        truncation: String? = nil,
        incompleteDetails: IncompleteDetails? = nil,
        error: ResponseError? = nil
    ) {
        self.id = id
        self.object = object
        self.createdAt = createdAt
        self.model = model
        self.output = output
        self.status = status
        self.usage = usage
        self.metadata = metadata
        self.previousResponseId = previousResponseId
        self.systemFingerprint = systemFingerprint
        self.store = store
        self.temperature = temperature
        self.topP = topP
        self.maxOutputTokens = maxOutputTokens
        self.truncation = truncation
        self.incompleteDetails = incompleteDetails
        self.error = error
    }

    /// Details about why a response is incomplete.
    public struct IncompleteDetails: Codable, Sendable {
        /// The reason the response is incomplete.
        public let reason: String?
    }

    /// Error information for a failed response.
    public struct ResponseError: Codable, Sendable {
        /// The error code.
        public let code: String?
        /// The error message.
        public let message: String?
    }
}

extension Response {
    /// Convenience: extracts the first text content from the output.
    public var outputText: String? {
        for item in output {
            if item.type == "message", let content = item.content {
                for c in content {
                    if c.type == "output_text", let text = c.text {
                        return text
                    }
                }
            }
        }
        return nil
    }
}

/// Response from deleting a response.
public struct ResponseDeleted: Codable, Sendable {
    public let id: String
    public let object: String
    public let deleted: Bool
}

/// Strategy for truncating input when context exceeds the model's limit.
public enum TruncationStrategy: Codable, Sendable {
    /// Automatically truncate from the beginning of the conversation.
    case auto
    /// Disable truncation (request will fail if too long).
    case disabled
    /// An unknown strategy returned by the API.
    case other(String)

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        switch value {
        case "auto": self = .auto
        case "disabled": self = .disabled
        default: self = .other(value)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .auto: try container.encode("auto")
        case .disabled: try container.encode("disabled")
        case .other(let value): try container.encode(value)
        }
    }
}

/// The service tier for processing the request.
public enum ServiceTier: Codable, Sendable {
    /// Default tier.
    case auto
    /// Default tier (alias for backward compatibility).
    case `default`
    /// Lower-latency tier.
    case flex
    /// An unknown tier returned by the API.
    case other(String)

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        switch value {
        case "auto": self = .auto
        case "default": self = .default
        case "flex": self = .flex
        default: self = .other(value)
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .auto: try container.encode("auto")
        case .default: try container.encode("default")
        case .flex: try container.encode("flex")
        case .other(let value): try container.encode(value)
        }
    }
}

// MARK: - Output Items

/// An output item in a response. Uses `type` field for discrimination.
///
/// Common types: `"message"`, `"function_call"`, `"reasoning"`, `"compaction"`.
public struct ResponseOutputItem: Codable, Sendable {
    /// The type of output item.
    public let type: String
    /// The unique identifier for this output item.
    public let id: String?
    /// The role of the output item author (for message type).
    public let role: String?
    /// The status of this output item.
    public let status: String?
    /// The content parts of this output item (for message type).
    public let content: [ResponseContentPart]?

    // MARK: Function Call fields

    /// The call ID for function calls. Must be echoed back in function_call_output.
    public let callId: String?
    /// The function name being called.
    public let name: String?
    /// The function arguments as a JSON string.
    public let arguments: String?
    /// The code to execute for code interpreter calls.
    public let code: String?

    // MARK: Reasoning fields

    /// The reasoning summary text.
    public let summary: [ResponseReasoningSummary]?

    private enum CodingKeys: String, CodingKey {
        case type, id, role, status, content, callId, name, arguments, code, summary
    }
}

/// A content part in a response output item.
public struct ResponseContentPart: Codable, Sendable {
    /// The type of content part (e.g. `"output_text"`, `"refusal"`).
    public let type: String
    /// The text content, if this is a text part.
    public let text: String?
    /// The refusal message, if this is a refusal part.
    public let refusal: String?
    /// Annotations on the text content.
    public let annotations: [ResponseAnnotation]?
}

/// An annotation on response text content.
public struct ResponseAnnotation: Codable, Sendable {
    /// The annotation type (e.g. `"url_citation"`, `"file_citation"`).
    public let type: String
    /// The start index of the annotated text.
    public let startIndex: Int?
    /// The end index of the annotated text.
    public let endIndex: Int?
    /// The URL for URL citations.
    public let url: String?
    /// The title of the cited source.
    public let title: String?
}

/// A reasoning summary in a reasoning output item.
public struct ResponseReasoningSummary: Codable, Sendable {
    /// The type, typically `"summary_text"`.
    public let type: String
    /// The summary text.
    public let text: String?
}

// MARK: - Token Usage

/// Token usage statistics for a response.
public struct ResponseUsage: Codable, Sendable {
    /// The number of input tokens used.
    public let inputTokens: Int
    /// The number of output tokens generated.
    public let outputTokens: Int
    /// The total number of tokens used.
    public let totalTokens: Int
    /// Details about output token usage.
    public let outputTokensDetails: OutputTokensDetails?

    /// Detailed breakdown of output token usage.
    public struct OutputTokensDetails: Codable, Sendable {
        /// The number of reasoning tokens used.
        public let reasoningTokens: Int?

        private enum CodingKeys: String, CodingKey {
            case reasoningTokens
        }
    }

    private enum CodingKeys: String, CodingKey {
        case inputTokens, outputTokens, totalTokens, outputTokensDetails
    }
}

// MARK: - Input Types

/// Input for the Responses API.
///
/// Can be a simple text string or an array of input items.
public enum ResponseInput: Encodable, Sendable {
    /// A simple text input.
    case text(String)
    /// An array of input messages.
    case messages([ResponseInputMessage])
    /// An array of input items (for multi-turn with tool results).
    case items([ResponseInputItem])

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .text(let text):
            try container.encode(text)
        case .messages(let messages):
            try container.encode(messages)
        case .items(let items):
            try container.encode(items)
        }
    }
}

/// A message in the Responses API input.
public struct ResponseInputMessage: Encodable, Sendable {
    /// The role of the message author.
    public let role: String
    /// The text content of the message.
    public let content: String

    public init(role: String, content: String) {
        self.role = role
        self.content = content
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode("message", forKey: .type)
        try container.encode(role, forKey: .role)
        try container.encode(content, forKey: .content)
    }

    private enum CodingKeys: String, CodingKey {
        case type, role, content
    }
}

/// An input item for multi-turn conversations with tool use.
public enum ResponseInputItem: Encodable, Sendable {
    /// A message input item.
    case message(ResponseInputMessage)
    /// A function call output (your function's result sent back to the model).
    case functionCallOutput(FunctionCallOutput)
    /// Echo back the model's function call item for context.
    case functionCall(FunctionCallItem)
    /// An item reference by ID.
    case itemReference(ItemReference)

    public func encode(to encoder: Encoder) throws {
        switch self {
        case .message(let msg):
            var container = encoder.singleValueContainer()
            // Wrap with type field
            try container.encode(MessageInputWrapper(type: "message", role: msg.role, content: msg.content))
        case .functionCallOutput(let output):
            try output.encode(to: encoder)
        case .functionCall(let call):
            try call.encode(to: encoder)
        case .itemReference(let ref):
            try ref.encode(to: encoder)
        }
    }
}

/// Wrapper for encoding message input items with a `type` field.
struct MessageInputWrapper: Encodable, Sendable {
    let type: String
    let role: String
    let content: String
}

/// A function call output sent back to the model.
public struct FunctionCallOutput: Encodable, Sendable {
    /// The type, always `"function_call_output"`.
    public let type: String
    /// The call ID from the model's function call. Must match.
    public let callId: String
    /// The output of your function as a string.
    public let output: String

    /// Creates a function call output.
    ///
    /// - Parameters:
    ///   - callId: The call ID from the model's `ResponseFunctionToolCall`.
    ///   - output: Your function's result as a string (typically JSON).
    public init(callId: String, output: String) {
        self.type = "function_call_output"
        self.callId = callId
        self.output = output
    }
}

/// A function call item echoed back to provide context.
public struct FunctionCallItem: Encodable, Sendable {
    /// The type, always `"function_call"`.
    public let type: String
    /// The call ID.
    public let callId: String
    /// The function name.
    public let name: String
    /// The function arguments as a JSON string.
    public let arguments: String

    /// Creates a function call item for echoing back to the model.
    public init(callId: String, name: String, arguments: String) {
        self.type = "function_call"
        self.callId = callId
        self.name = name
        self.arguments = arguments
    }
}

/// An item reference by ID.
public struct ItemReference: Encodable, Sendable {
    /// The type, always `"item_reference"`.
    public let type: String
    /// The ID of the item to reference.
    public let id: String

    /// Creates an item reference.
    public init(id: String) {
        self.type = "item_reference"
        self.id = id
    }
}

// MARK: - Tool Types

/// A tool that can be used with the Responses API.
public enum ResponseTool: Encodable, Sendable {
    /// A function tool for custom function calling.
    case function(FunctionToolDefinition)
    /// A web search tool.
    case webSearch(WebSearchToolDefinition)
    /// A code interpreter tool.
    case codeInterpreter(CodeInterpreterToolDefinition)
    /// A file search tool.
    case fileSearch(FileSearchToolDefinition)

    public func encode(to encoder: Encoder) throws {
        switch self {
        case .function(let def):
            try def.encode(to: encoder)
        case .webSearch(let def):
            try def.encode(to: encoder)
        case .codeInterpreter(let def):
            try def.encode(to: encoder)
        case .fileSearch(let def):
            try def.encode(to: encoder)
        }
    }
}

/// A function tool definition.
public struct FunctionToolDefinition: Encodable, Sendable {
    /// The type, always `"function"`.
    public let type: String
    /// The name of the function.
    public let name: String
    /// A description of what the function does.
    public let description: String?
    /// The function parameters as a JSON Schema object.
    public let parameters: [String: AnyCodable]?
    /// Whether to enforce strict parameter validation.
    public let strict: Bool?

    /// Creates a function tool definition.
    ///
    /// - Parameters:
    ///   - name: The function name.
    ///   - description: What the function does.
    ///   - parameters: JSON Schema for the function parameters.
    ///   - strict: Whether to enforce strict schema validation (default: true).
    public init(
        name: String,
        description: String? = nil,
        parameters: [String: AnyCodable]? = nil,
        strict: Bool? = true
    ) {
        self.type = "function"
        self.name = name
        self.description = description
        self.parameters = parameters
        self.strict = strict
    }
}

/// A web search tool definition.
public struct WebSearchToolDefinition: Encodable, Sendable {
    /// The type, always `"web_search_preview"`.
    public let type: String

    /// Creates a web search tool definition.
    public init() {
        self.type = "web_search_preview"
    }
}

public struct CodeInterpreterToolDefinition: Encodable, Sendable {
    /// The type, always "code_interpreter".
    public let type: String
    /// Container ID for file access.
    public let container: String?

    public init(container: String? = nil) {
        self.type = "code_interpreter"
        self.container = container
    }
}

public struct FileSearchToolDefinition: Encodable, Sendable {
    /// The type, always "file_search".
    public let type: String
    /// Vector store IDs to search.
    public let vectorStoreIds: [String]
    /// Maximum number of results.
    public let maxNumResults: Int?

    public init(vectorStoreIds: [String], maxNumResults: Int? = nil) {
        self.type = "file_search"
        self.vectorStoreIds = vectorStoreIds
        self.maxNumResults = maxNumResults
    }
}

// MARK: - Tool Choice

/// Controls which tool the model should use.
public enum ResponseToolChoice: Encodable, Sendable {
    /// Let the model decide.
    case auto
    /// Force the model to use a tool.
    case required
    /// Prevent tool use. Named `disabled` to avoid collision with `Optional.none`.
    case disabled
    /// Force a specific function.
    case function(String)

    public func encode(to encoder: Encoder) throws {
        switch self {
        case .auto:
            var container = encoder.singleValueContainer()
            try container.encode("auto")
        case .required:
            var container = encoder.singleValueContainer()
            try container.encode("required")
        case .disabled:
            var container = encoder.singleValueContainer()
            try container.encode("none")
        case .function(let name):
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode("function", forKey: .type)
            try container.encode(name, forKey: .name)
        }
    }

    private enum CodingKeys: String, CodingKey {
        case type, name
    }
}

// MARK: - Text Format (Structured Outputs)

/// Configuration for the text output format.
public struct ResponseTextConfig: Encodable, Sendable {
    /// The output format.
    public let format: ResponseTextFormat

    /// Creates a text configuration.
    public init(format: ResponseTextFormat) {
        self.format = format
    }
}

/// The text output format for responses.
public enum ResponseTextFormat: Encodable, Sendable {
    /// Plain text output (default).
    case text
    /// JSON object output.
    case jsonObject
    /// Structured JSON output with a schema.
    case jsonSchema(ResponseTextFormatJSONSchema)

    public func encode(to encoder: Encoder) throws {
        switch self {
        case .text:
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode("text", forKey: .type)
        case .jsonObject:
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode("json_object", forKey: .type)
        case .jsonSchema(let schema):
            try schema.encode(to: encoder)
        }
    }

    private enum CodingKeys: String, CodingKey {
        case type
    }
}

/// JSON Schema format configuration for structured outputs.
public struct ResponseTextFormatJSONSchema: Encodable, Sendable {
    /// The type, always `"json_schema"`.
    public let type: String
    /// The name of the schema.
    public let name: String
    /// The JSON Schema definition.
    public let schema: [String: AnyCodable]
    /// A description of the schema.
    public let description: String?
    /// Whether to enforce strict schema adherence.
    public let strict: Bool?

    /// Creates a JSON Schema format configuration.
    ///
    /// - Parameters:
    ///   - name: A name for the schema.
    ///   - schema: The JSON Schema as a dictionary.
    ///   - description: An optional description.
    ///   - strict: Whether to enforce strict adherence (recommended: true).
    public init(
        name: String,
        schema: [String: AnyCodable],
        description: String? = nil,
        strict: Bool? = true
    ) {
        self.type = "json_schema"
        self.name = name
        self.schema = schema
        self.description = description
        self.strict = strict
    }
}

// MARK: - Context Management (Compaction)

/// Context management configuration for long conversations.
public struct ContextManagement: Encodable, Sendable {
    /// The type, currently only `"compaction"`.
    public let type: String
    /// The token threshold at which compaction is triggered.
    public let compactThreshold: Int?

    /// Creates a compaction context management configuration.
    ///
    /// - Parameter compactThreshold: Token count threshold to trigger compaction.
    public init(compactThreshold: Int? = nil) {
        self.type = "compaction"
        self.compactThreshold = compactThreshold
    }
}

// MARK: - Reasoning Configuration

/// Configuration for reasoning models (o-series).
public struct ReasoningConfig: Encodable, Sendable {
    /// The reasoning effort level.
    public let effort: String?

    /// Creates a reasoning configuration.
    ///
    /// - Parameter effort: The effort level: `"low"`, `"medium"`, or `"high"`.
    public init(effort: String? = nil) {
        self.effort = effort
    }
}

// MARK: - Compacted Response

/// A response from the compact endpoint.
public struct CompactedResponse: Codable, Sendable {
    /// The unique identifier.
    public let id: String
    /// The object type, always `"response.compaction"`.
    public let object: String
    /// The Unix timestamp of creation.
    public let createdAt: Int
    /// The compacted output items.
    public let output: [ResponseOutputItem]
    /// Token usage for the compaction.
    public let usage: ResponseUsage?
}

// MARK: - Create Parameters

/// Parameters for creating a response.
struct ResponseCreateParams: Encodable, Sendable {
    let model: String
    let input: ResponseInput
    let instructions: String?
    let maxOutputTokens: Int?
    let temperature: Double?
    let topP: Double?
    let stream: Bool?
    let store: Bool?
    let metadata: [String: String]?
    let previousResponseId: String?
    let conversation: String?
    let tools: [ResponseTool]?
    let toolChoice: ResponseToolChoice?
    let text: ResponseTextConfig?
    let truncation: TruncationStrategy?
    let contextManagement: [ContextManagement]?
    let reasoning: ReasoningConfig?
    let parallelToolCalls: Bool?
    let maxToolCalls: Int?
    let serviceTier: ServiceTier?

    init(
        model: String,
        input: ResponseInput,
        instructions: String? = nil,
        maxOutputTokens: Int? = nil,
        temperature: Double? = nil,
        topP: Double? = nil,
        stream: Bool? = nil,
        store: Bool? = nil,
        metadata: [String: String]? = nil,
        previousResponseId: String? = nil,
        conversation: String? = nil,
        tools: [ResponseTool]? = nil,
        toolChoice: ResponseToolChoice? = nil,
        text: ResponseTextConfig? = nil,
        truncation: TruncationStrategy? = nil,
        contextManagement: [ContextManagement]? = nil,
        reasoning: ReasoningConfig? = nil,
        parallelToolCalls: Bool? = nil,
        maxToolCalls: Int? = nil,
        serviceTier: ServiceTier? = nil
    ) {
        self.model = model
        self.input = input
        self.instructions = instructions
        self.maxOutputTokens = maxOutputTokens
        self.temperature = temperature
        self.topP = topP
        self.stream = stream
        self.store = store
        self.metadata = metadata
        self.previousResponseId = previousResponseId
        self.conversation = conversation
        self.tools = tools
        self.toolChoice = toolChoice
        self.text = text
        self.truncation = truncation
        self.contextManagement = contextManagement
        self.reasoning = reasoning
        self.parallelToolCalls = parallelToolCalls
        self.maxToolCalls = maxToolCalls
        self.serviceTier = serviceTier
    }
}

/// Parameters for compacting a response context.
struct ResponseCompactParams: Encodable, Sendable {
    let model: String
    let input: ResponseInput?
    let instructions: String?
    let previousResponseId: String?
}

// MARK: - Streaming Events

/// A streamed event from the Responses API.
///
/// Events use the `type` field for discrimination. Common events:
/// - `response.created`, `response.completed`, `response.failed`
/// - `response.output_text.delta`, `response.output_text.done`
/// - `response.function_call_arguments.delta`, `response.function_call_arguments.done`
/// - `response.refusal.delta`, `response.refusal.done`
/// - `response.output_item.added`, `response.output_item.done`
/// - `response.content_part.added`, `response.content_part.done`
public struct ResponseStreamEvent: Codable, Sendable {
    /// The event type.
    public let type: String
    /// The full response object (for lifecycle events like created/completed).
    public let response: Response?
    /// The output item (for output_item.added/done events).
    public let item: ResponseOutputItem?
    /// The content part (for content_part.added/done events).
    public let part: ResponseContentPart?
    /// The incremental text delta (for output_text.delta events).
    public let delta: String?
    /// The output index for multi-output responses.
    public let outputIndex: Int?
    /// The content index within an output item.
    public let contentIndex: Int?
    /// The item ID associated with this event.
    public let itemId: String?
    /// The incremental text content (for content.done events).
    public let text: String?
    /// The function call arguments (for function_call_arguments events).
    public let arguments: String?
    /// The function name (for function_call_arguments.done events).
    public let name: String?
    /// The call ID for function calls.
    public let callId: String?
    /// The sequence number for ordering events.
    public let sequenceNumber: Int?

    private enum CodingKeys: String, CodingKey {
        case type, response, item, part, delta, outputIndex, contentIndex
        case itemId, text, arguments, name, callId, sequenceNumber
    }
}
